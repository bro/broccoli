<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V4.2//EN" [
<!ENTITY bc "<function>broccoli</function>">
<!ENTITY bcc "<filename>broccoli-config</filename>">
<!ENTITY bc-latest-rel "1.5">
<!ENTITY bc-header SYSTEM "sgml/broccoli.sgml">
<!ENTITY bp "<function>broping</function>">
]>
<book id="index">
  <title>Broccoli: The Bro Client Communications Library</title>
  <bookinfo>
    <mediaobject>
      <imageobject>
	<imagedata fileref="images/logo.jpg" format="jpg" align="center">
      </imageobject>
      <textobject>
	<phrase>Broccoli Logo</phrase>
      </textobject>
    </mediaobject>
    <abstract>
      <para>
	This is documentation for release <emphasis>&bc-latest-rel;</emphasis>
	of Broccoli, compatible with Bro IDS releases of <emphasis>1.4</emphasis>
	or newer. Broccoli is free software under terms of the BSD license as given
	in the <link linkend="license" endterm="license.title">License</link>
	section. This documentation is always available on the web for download
	and online browsing at
	<ulink url="http://www.icir.org/christian/broccoli">http://www.icir.org/christian/broccoli</ulink>.
      </para>
      <para>Feedback, patches and bug reports are all welcome, please
	<ulink url="http://mailman.icsi.berkeley.edu/mailman/listinfo/bro">join the Bro mailing list</ulink>.
      </para>
      <para>
	Yet Another SRG/ICIR Production &mdash;
	<ulink url="http://www.cl.cam.ac.uk/Research/SRG">http://www.cl.cam.ac.uk/Research/SRG</ulink> &mdash;
	<ulink url="http://www.icir.org">http://www.icir.org</ulink>
      </para>
    </abstract>
  </bookinfo>

  <chapter>
    <title>Introduction</title>
    <para>
    Welcome! You're looking at the Broccoli manual. Thanks for reading this.
    </para>
    <sect1>
      <title>What is Broccoli?</title>
      <para>
	Broccoli is the <emphasis>BRO</emphasis> <emphasis>C</emphasis>lient
	<emphasis>CO</emphasis>mmunications <emphasis>LI</emphasis>brary. It allows
	you to write applications that speak the communication protocol of the
	<ulink url="http://www.bro-ids.org">Bro intrusion detection system</ulink>.	
	In this document, we assume that you are familiar with the basic concepts
	of Bro. If you need a refresher, please have a look at the
	<ulink url="http://www.icir.org/vern/papers/bro-CN99.html">original paper</ulink>,
	the <ulink url="http://www.bro-ids.org/Bro-user-manual/index.html">user manual</ulink>,
	and the material on <ulink url="http://www.bro-ids.org">bro-ids.org</ulink> in general.
      </para>      
    </sect1>
    <sect1>
      <title>Why do I care?</title>
      <para>
        Having a single IDS on your network is good, but things become a lot more interesting
	when you can communicate information among multiple vantage points in your network.
	Bro agents can communicate with other Bro agents, sending and receiving events and
	other state information. In the Bro context this is particularly interesting because
	it means that you can build sophisticated policy-controlled distributed event
	management systems.
      </para>
      <para>
	Broccoli enters the picture when it comes to integrating components that are not
	Bro agents themselves. Broccoli lets you create applications that can speak the Bro
	communication protocol. You can compose, send, request, and receive events.
	You can register your own event handlers. You can talk to other Broccoli
	applications or Bro agents &mdash; Bro agents cannot tell whether they are talking
	to another Bro or a Broccoli application. Broccoli allows you to integrate applications
	of your choosing into a distributed policy-controlled event management system.
	Broccoli is intended
	to be portable: it should build on Linux, the BSDs, Solaris, and Windows
	(in the <ulink url="http://www.mingw.org">MinGW</ulink> environment).
      </para>
      <para>
	Unlike other distributed IDSs, Bro does not assume a strict sensor&ndash;manager
	hierarchy in the information flow. Instead, Bro agents can request delivery of
	arbitrary <emphasis>events</emphasis>
	from other instances. When an event is triggered in a Bro agent, it checks
	whether any connected agents have requested notification of this event,
	and send a <emphasis>copy</emphasis> of the event, including the <emphasis>event arguments</emphasis>.
	Recall that in Bro, an event handler is essentially a function defined in
	the Bro language, and an event materializes through invocation of an event handler.
	Each remote agent can define its own event handlers.
      </para>
      <para>
        Broccoli applications will typically do one or more of the following:
      </para>
      <itemizedlist>	 
	<listitem>
	  <para>
	   <emphasis>Configuration/Management Tasks:</emphasis> the Broccoli application
	   is used to configure remotely running Bros without the need for a restart.
	  </para>
	</listitem>
	<listitem>
	  <para>
	   <emphasis>Interfacing other Systems:</emphasis> the Broccoli application
	   is used to convert Bro events to other alert/notice formats, for into
	   syslogd entries.
	  </para>
	</listitem>
	<listitem>
	  <para>
	   <emphasis>Host-based Sensor Feeds into Bro:</emphasis> the Broccoli
	   application reports events based on host-based activity generated in
	   kernel space or user space applications.
	  </para>
	</listitem>
      </itemizedlist>	 
    </sect1>
  </chapter>

  <chapter>
    <title>Installing Broccoli</title>
    <para>
      The installation process will hopefully be painless: Broccoli is installed from source
      using the usual <command>./configure &lt;options&gt; && make && make install</command>
      routine after extraction of the tarball. Or if you're on a Linux systems supporting
      RPMs, we provide those as well.
    </para>
    <para>
      The relevant configuration options to pass to configure are:
      <itemizedlist>	 
	<listitem>
	  <para><command>--prefix=&lt;DIR&gt;</command>: sets the installation root to DIR.
	  The default is to install below <filename>/usr/local</filename>.</para>
	</listitem>
	<listitem>
	  <para><command>--enable-debug</command>: enables debugging output.
          Please refer to the <link linkend="broccoli-debugging">Broccoli debugging</link>
	  section for details on configuring and using debugging output.
          </para>
	</listitem>
	<listitem>
	  <para><command>--with-configfile=&lt;FILE&gt;</command>: use FILE as location of configuration file.
	  See the section on <link linkend="config-files">configuration files</link>
	  below for more on this.
	  </para>
	</listitem>
	<listitem>
	  <para><command>--with-openssl=&lt;DIR&gt;</command>: use the OpenSSL installation below DIR.</para>
	</listitem>
	<listitem>
	  <para><command>--with-kerberos=&lt;DIR&gt;</command>: use the Kerberos installation below DIR.</para>
	</listitem>
      </itemizedlist>
    </para>
    <para>
      After installation, you'll find the library in shared and static versions in <filename>&lt;prefix&gt;/lib</filename>
      the header file for compilation in <filename>&lt;prefix&gt;/include</filename>, and the
      manual in HTML below <filename>&lt;prefix&gt;/share/gtk-doc/html/broccoli</filename>.      
    </para>
    <para>
      When installing from source, you can get rid of the installation using <command>make uninstall</command>.
    </para>
  </chapter>
  
  <chapter>
    <title>Using Broccoli</title>
    <para>
    </para>

    <sect1>
      <title>Obtaining information about your build using <filename>broccoli-config</filename></title>
      <para>
	Similarly to many other software packages, the Broccoli distribution
	provides a script that you can use to obtain details about your
	Broccoli setup. The script currently provides the following flags:
	<itemizedlist>	 
	  <listitem>
	    <para><command>--build</command> prints the name of the machine the build was
		made on, when, and whether debugging support was enabled or not.</para>
	  </listitem>
	  <listitem>
	    <para><command>--prefix</command> prints the directory in the filesystem
		below which Broccoli was installed.</para>
	  </listitem>
	  <listitem>
	    <para><command>--version</command> prints the version of the distribution
		you have installed.</para>
	  </listitem>
	  <listitem>
	    <para><command>--libs</command> prints the flags to pass to the
		linker in order to link in the Broccoli library.</para>
	  </listitem>
	  <listitem>
	    <para><command>--cflags</command> prints the flags to pass to the
		compiler in order to properly include Broccoli's header file.</para>
	  </listitem>
	  <listitem>
	    <para><command>--config</command> prints the location of the system-wide
		config file your installation will use.</para>
	  </listitem>
	</itemizedlist>	 
      </para>
      <para>
	  The <filename>--cflags</filename> and <filename>--libs</filename> flags
	  are the suggested way of obtaining the necessary information for integrating
	  Broccoli into your build environment. It is generally recommended to use
	  <filename>broccoli-config</filename> for this purpose, rather than, say,
	  develop new <command>autoconf </command> tests. 
          If you use the <command>autoconf</command>/<command>automake</command>
          tools, we recommend something along the following lines for your
	  <filename>configure</filename> script:
      </para>      
      <programlisting>
<![CDATA[
dnl ##################################################
dnl # Check for Broccoli
dnl ##################################################
AC_ARG_WITH(broccoli-config,
    AC_HELP_STRING([--with-broccoli-config=FILE], [Use given broccoli-config]),
    [ brocfg="$withval" ],
    [ AC_PATH_GENERIC(broccoli,,
          brocfg="broccoli-config",
          AC_MSG_ERROR(Cannot find Broccoli: Is broccoli-config in path? Use more fertilizer?)) ])

broccoli_libs=`$brocfg --libs`
broccoli_cflags=`$brocfg --cflags`
AC_SUBST(broccoli_libs)
AC_SUBST(broccoli_cflags)
]]>
      </programlisting>
      <para>
      You can then use the compiler/linker flags in your Makefile.in/ams by
      substituting in the values accordingly, which might look as follows:
      </para>
      <programlisting>
<![CDATA[
CFLAGS = -W -Wall -g -DFOOBAR @broccoli_cflags@
LDFLAGS = -L/usr/lib/foobar @broccoli_libs@
]]>
      </programlisting>
    </sect1>

    <sect1>
      <title>Suggestions for instrumenting applications</title>
      <para>
          Often you will want to make existing applications Bro-aware,
	  that is, <emphasis>instrument</emphasis> them so that they can send and
	  receive Bro events at appropriate moments in the execution flow.
	  This will involve modifying an existing code tree, so care needs to
	  be taken to avoid unwanted side effects. By protecting the instrumented
	  code with
	  <function>#ifdef</function>/<function>#endif</function>
	  statements you can still build the original application, using the
	  instrumented source tree. The &bcc; script helps you in doing so because
	  it already adds <function>-DBROCCOLI</function> to the compiler flags
	  reported when run with the <filename>--cflags</filename> option:
      </para>
      <programlisting>
<![CDATA[
cpk25@localhost:/home/cpk25 > broccoli-config --cflags
-I/usr/local/include -I/usr/local/include -DBROCCOLI
]]>
      </programlisting>
      <para>
	  So simply surround all inserted code with a preprocessor check
	  for <function>BROCCOLI</function> and you will be able to
	  build the original application as soon as <function>BROCCOLI</function>
	  is not defined.
      </para>
    </sect1>
    <sect1>
      <title>The Broccoli API</title>
      <para>
          Time for some code. In the code snippets below we will introduce variables
	  whenever context requires them and not necessarily when C requires them.
	  The library does not require calling a global initialization function.
	  In order to make the API known, include <filename>broccoli.h</filename>:
      </para>
      <programlisting>
<![CDATA[
#ifdef BROCCOLI
#include <broccoli.h>
#endif
]]>
      </programlisting>
      <note>
        <para><emphasis>A note on Broccoli's memory management philosophy:</emphasis></para>
	  <para>Broccoli generally does not release objects you allocate.
	    The approach taken is "you clean up what you allocate."
	</para>
      </note>

      <sect2>
	<title>Initialization</title>
        <para>
	  Broccoli requires global initialization before most of its
	  other other functions can be used. Generally, the way to
	  initialize Broccoli is as follows:
        </para>
        <programlisting>
<![CDATA[
bro_init(NULL);
]]>
        </programlisting>
        <para>
          The argument to
          <link linkend="bro-init"><function>bro_init()</function></link>
          provides optional initialization context, and may be kept
          <constant>NULL</constant> for normal use. If required, you may
          allocate a <filename>BroCtx</filename> structure locally,
          initialize it using
          <link linkend="bro-ctx-init"><function>bro_ctx_init()</function></link>,
          fill in additional values as required and and subsequently pass it to
          <link linkend="bro-init"><function>bro_init()</function></link>:
        </para>
        <programlisting>
<![CDATA[
BroCtx ctx;
bro_ctx_init(&ctx);
/* Make adjustments to the context structure as required... */
bro_init(&ctx);
]]>
        </programlisting>
	<caution>
          <para>
          The <filename>BroCtx</filename> structure currently contains
          a set of five different callback function pointers.  These
          are <emphasis>required</emphasis> for thread-safe operation
          of OpenSSL (Broccoli itself is thread-safe).  If you intend
          to use Broccoli in a multithreaded environment, you need to
          implement functions and register them via the
          <filename>BroCtx</filename> structure.  The O'Reilly book
          "Network Security with OpenSSL" by Viega et al. shows how to
          implement these callbacks.
          </para>
	</caution>
	<caution>
	  <para>You <emphasis>must</emphasis> call
          <link linkend="bro-init"><function>bro_init()</function></link>
	  at the start of your application. Undefined behavior may result
          if you don't.
          </para>
	</caution>
      </sect2>

      <sect2>
	<title>Data types in Broccoli</title>
        <para>
	  Broccoli declares a number of data types in <filename>broccoli.h</filename> that
	  you should know about. The more complex ones are kept opaque, while you do get
	  access to the fields in the simpler ones. The full list is as follows:

	  <itemizedlist>	 
	    <listitem>
	      <para>Simple signed and unsigned types: <type>int</type>, <type>uint</type>,
	        <type>uint32</type>, <type>uint16</type> and <type>uchar</type>.</para>
	    </listitem>
	    <listitem>
	      <para>Connection handles: <type>BroConn</type>, kept opaque.</para>
	    </listitem>
	    <listitem>
	      <para>Bro events: <type>BroEvent</type>, kept opaque.</para>
	    </listitem>
	    <listitem>
	      <para>Buffer objects: <type>BroBuf</type>, kept opaque. See the separate
	      <link linkend="buffers">section on buffer management</link> for details.</para>
	    </listitem>
	    <listitem>
	      <para>Ports: <type>BroPort</type> for network ports, defined as follows:
	      </para>
	      <programlisting>
<![CDATA[
typedef struct bro_port {
  uint16       port_num;   /* port number in host byte order */
  int          port_proto; /* IPPROTO_xxx */
} BroPort;
]]>
              </programlisting>
	    </listitem>
	    <listitem>
	      <para>Records: <type>BroRecord</type>, kept opaque. See the separate
	      <link linkend="records">section on record handling</link> for details.</para>
	    </listitem>
	    <listitem>
	      <para>Strings (character and binary): <type>BroString</type>, defined as follows:
	      </para>
	      <programlisting>
<![CDATA[
typedef struct bro_string {
  int          str_len;
  char        *str_val;
} BroString;
]]>
              </programlisting>
	      <para>
	      BroStrings are mostly kept transparent for convenience; please have a look at the
	      string API:
<link linkend="bro-string-init"><function>bro_string_init()</function></link>,
<link linkend="bro-string-set"><function>bro_string_set()</function></link>,
<link linkend="bro-string-set-data"><function>bro_string_set_data()</function></link>,
<link linkend="bro-string-copy"><function>bro_string_copy()</function></link>,
<link linkend="bro-string-cleanup"><function>bro_string_cleanup()</function></link>, and
<link linkend="bro-string-free"><function>bro_string_free()</function></link>.
	      </para>
	    </listitem>
	    <listitem>
	      <para>Tables: <type>BroTable</type>, kept opaque. See the separate
	      <link linkend="tables">section on table handling</link> for details.</para>
	    </listitem>
	    <listitem>
	      <para>Sets: <type>BroSet</type>, kept opaque. See the separate
	      <link linkend="sets">section on table handling</link> for details.</para>
	    </listitem>
	    <listitem>
	      <para>Subnets: <type>BroSubnet</type>, defined as follows:
	      </para>
	      <programlisting>
<![CDATA[
typedef struct bro_subnet
{
  uint32       sn_net;     /* IP address in network byte order */
  uint32       sn_width;   /* Length of prefix to consider. */
} BroSubnet;
]]>
              </programlisting>
	    </listitem>
	  </itemizedlist>
	</para>
      </sect2>

      <sect2>
	<title>Managing connections</title>
        <para>
	    You can use Broccoli to establish a connection to a remote Bro, or to create a
	    Broccoli-enabled server application that other Bros will connect to. (This
	    means that in principle, you can also use Broccoli purely as middleware and
	    have multiple Broccoli applications communicate directly.)
        </para>
        <para>	    
	    In order to establish a connection to a remote Bro, you first obtain a connection
	    handle. You then use this connection handle to request events, connect to the
	    remote Bro, send events, etc. Connection handles are pointers to <function>BroConn</function>
	    structures, which are kept opaque. Use
	    <link linkend="bro-conn-new"><function>bro_conn_new()</function></link> or
	    <link linkend="bro-conn-new-str"><function>bro_conn_new_str()</function></link>
	    to obtain a handle, depending on what parameters are more convenient for
	    you: the former accepts the IP address and port number as separate numerical
	    arguments, the latter uses a single string to encode both, in "hostname:port"
	    format.
        </para>
        <para>
	    To write a Broccoli-enabled server, you first need to implement the usual
	    <function>socket()</function> / <function>bind()</function> /
	    <function>listen()</function> / <function>accept()</function> routine.
	    Once you have obtained a file descriptor for the new connection from <function>accept()</function>,
	    you pass it to the third function that returns a <function>BroConn</function>
	    handle, 
	    <link linkend="bro-conn-new-socket"><function>bro_conn_new_socket()</function></link>.
	    The rest of the connection handling then proceeds as in the client scenario.
        </para>
        <para>	    
	    All three calls accept additional flags for fine-tuning connection behaviour.
	    These flags are:
	    <itemizedlist>	    
              <listitem>
                <para><constant>BRO_CFLAG_NONE</constant>: no functionality. Use when
		  no flags are desired.
		</para>
              </listitem>
              <listitem>
                <para><constant>BRO_CFLAG_RECONNECT</constant>:
		  When using this option, Broccoli will attempt to reconnect to the peer
		  after lost connectivity transparently. Essentially whenever you try to
		  read from or write to the peer and its connection broke down, a
		  full reconnect including complete handshaking is attempted. You can check
		  whether the connection to a peer is alive at any time using
	    	  <link linkend="bro-conn-alive"><function>bro_conn_alive()</function></link>.
		</para>
	      </listitem> 
              <listitem>
                <para><constant>BRO_CFLAG_ALWAYS_QUEUE</constant>:
		  When using this option, Broccoli will queue any events you send for
		  later transmission when a connection is currently down. Without using this
		  flag, any events you attempt to send while a connection is down get dropped
		  on the floor. Note that Broccoli maintains a maximum queue size per connection
		  so if you attempt to send lots of events while the connection is down, the
		  oldest events may start to get dropped nonetheless. Again, you can check
		  whether the connection is currently okay by using
	    	  <link linkend="bro-conn-alive"><function>bro_conn_alive()</function></link>.
		</para>
	      </listitem> 		  
              <listitem>
                <para><constant>BRO_CFLAG_DONTCACHE</constant>:
		  When using this option, Broccoli will ask the peer not to use caching on
		  the objects it sends to us. This is the default, and the flag need not
		  normally be used. It is kept to maintain backward compatibility.
		</para>
	      </listitem> 		  
              <listitem>
                <para><constant>BRO_CFLAG_CACHE</constant>:
		  When using this option, Broccoli will ask the peer to use caching on
		  the objects it sends to us. Caching is normally disabled.
		</para>
	      </listitem> 		  
              <listitem>
                <para><constant>BRO_CFLAG_YIELD</constant>: When
                using this option,
                <function>bro_conn_process_input()</function>
                processes at most one event at a time and then
                returns. 
		</para>
              </listitem>
	    </itemizedlist>
                
        </para>
	<para>
	    By obtaining a connection handle, you do not also establish a connection right
	    away. This is done using 
	    <link linkend="bro-conn-connect"><function>bro_conn_connect()</function></link>.
	    The main reason for this is to allow you to subscribe to events
	    (using
	    <link linkend="bro-event-registry-add"><function>bro_event_registry_add()</function></link>,
	    see <link linkend="receiving-events">below</link>)
	    before establishing the connection. Upon returning from 
	    <link linkend="bro-conn-connect"><function>bro_conn_connect()</function></link>
	    you are guaranteed to receive all instances of the event types you have
	    requested, while later on during the connection some time may elapse between
	    the issuing of a request for events and the processing of that request at the
	    remote end.
	    Connections are established via TCP, optionally using SSL encryption. See
	    <link linkend="encryption">"Configuring encrypted communication"</link> below for more
	    information on setting up enncryption.
	    The port numbers Bro agents and Broccoli applications listen on can vary from peer
	    to peer. 
	</para>
	<para>
	    Finally, <link linkend="bro-conn-delete"><function>bro_conn_delete()</function></link>
	    terminates a connection and releases all resources associated with it.
	    You can create as many connections as you like, to one or more peers.
	    You can obtain the file descriptor of a connection using
	    <link linkend="bro-conn-get-fd"><function>bro_conn_get_fd()</function></link>.
        </para>
        <programlisting>
<![CDATA[
char host_str = "bro.yourorganization.com";
int port      = 1234;
struct hostent *host;
BroConn *bc;

if (! (host = gethostbyname(host_str)) ||
    ! (host->h_addr_list[0])) {
	/* Error handling -- could not resolve host */
}

/* In this example, we obtain a connection handle, then register event handlers,
 * and finally connect to the remote Bro.
 *
 * First obtain a connection handle:
 */
if (! (bc = bro_conn_new((struct in_addr*) host->h_addr_list[0], htons(port), BRO_CFLAG_NONE))) {
	/* Error handling  - could not get connection handle */
}

/* Register event handlers:
 */
bro_event_registry_add(bc, "foo", bro_foo_handler, NULL);
/* ... */

/* Now connect to the peer:
 */
if (! bro_conn_connect(bc)) {
	/* Error handling - could not connect to remote Bro. */
}

/* Send and receive events ... */

/* Disconnect from Bro and clean up connection */
bro_conn_delete(bc);
]]>
        </programlisting>
        <para>
	    Or simply use the string-based version:
	</para>
        <programlisting>
<![CDATA[
char host_str = "bro.yourcompany.com:1234";
BroConn *bc;

/* In this example we don't request any events from the peer, but
 * we ask it not to use the serialization cache.
 *
 * Again, first obtain a connection handle:
 */
if (! (bc = bro_conn_new_str(host_str, BRO_CFLAG_DONTCACHE))) {
	/* Error handling  - could not get connection handle */
}

/* Now connect to the peer:
 */
if (! bro_conn_connect(bc)) {
	/* Error handling - could not connect to remote Bro. */
}

/* ... */
]]>
        </programlisting>
      </sect2>

      <sect2>
	<title>Connection classes</title>
        <para>
	    When you want to establish connections from multiple Broccoli applications
	    with different purposes, the peer needs a means to understand what kind of
	    application each connection belongs to. The real meaning of "kind of application"
	    here is "sets of event types to request", because depending on the class of
	    an application, the peer will likey want to receive different types of events.
	</para>
	<para>
	    Broccoli lets you set the class of a connection using
	    <link linkend="bro-conn-set-class"><function>bro_conn_set_class()</function></link>.
	    When using this feature, you need to call that function before issuing a
	    <link linkend="bro-conn-connect"><function>bro_conn_connect()</function></link>,
	    since the class of a connection is determined at connection startup.
	</para>
        <programlisting>
<![CDATA[
if (! (bc = bro_conn_new_str(host_str, BRO_CFLAG_DONTCACHE))) {
	/* Error handling  - could not get connection handle */
}

/* Set class of this connection: */
bro_conn_set_class(bc, "syslog");

if (! bro_conn_connect(bc)) {
	/* Error handling - could not connect to remote Bro. */
}
]]>
        </programlisting>
	<para>
	    If your peer is a Bro node, you need to match the chosen connection class in
	    the remote Bro's <function>Remote::destinations</function> configuration.
	    See <link linkend="bro-event-config">below</link> for how to do this.
	    Finally, in order to obtain the class of a connection as indicated by the remote side, use
	    <link linkend="bro-conn-get-peer-class"><function>bro_conn_get_peer_class()</function></link>.
	</para>
      </sect2> 

      <sect2>
	<title>Composing and sending events</title>
        <para>
	    In order to send an event to the remote Bro agent, you first create
	    an empty event structure with the name of the event, then add parameters
	    to pass to the event handler at the remote agent, and then send off the
	    event.
        </para>
	<note>
	  <para>
            <emphasis>Bro peers ignore unrequested events.</emphasis>
          </para>
          <para>
	    You need to make sure that the remote Bro agent is interested in receiving
	    the events you send. This interest is expressed in policy configuration.
	    We'll explain this in more detail <link linkend="bro-event-config">below</link>
	    and for now assume that our remote peer is configured to receive the
	    events we send.
          </para>
	</note>
        <para>
	    Let's assume we want to request a report of all connections a remote
	    Bro currently keeps state for that match a given destination port and
	    host name and that have amassed more than a certain number of bytes.
	    The idea is to send an event to the remote Bro that contains the
	    query, identifiable through a request ID, and have the remote Bro
	    answer us with <function>remote_conn</function> events
	    containing the information we asked for. The definition of our
	    requesting event could look as follows in the Bro policy:
        </para>
        <programlisting>
<![CDATA[
event report_conns(req_id: int, dest_host: string, dest_port: port, min_size: count);
]]>
        </programlisting>
        <para>
            First, create a new event:
        </para>
        <programlisting>
<![CDATA[
BroEvent *ev;

if (! (ev = bro_event_new("report_conns"))) {
	/* Error handling - could not allocate new event. */
}
]]>
        </programlisting>
	<para>
	    Now we need to add parameters to the event. The sequence and types must
	    match the event handler declaration &mdash; check the Bro policy to make
	    sure they match. The function to use for adding parameter values is
	    <link linkend="bro-event-add-val"><function>bro_event_add_val()</function></link>
	    All values are passed as <emphasis>pointer arguments</emphasis> and are copied internally,
	    so the object you're pointing to stays unmodified at all times. You clean
	    up what you allocate. In order to indicate the type of the value passed into the
	    function, you need to pass a numerical type identifier along as well.
            <link linkend="table-1">Table 1</link> lists the value types that Broccoli supports along with
	    the type identifier and data structures to point to.
	</para>
<table frame="sides" id="table-1">
<title>Types, type tags, and data structures for event parameters in Broccoli</title>
<tgroup cols="3" align="left" colsep="1" rowsep="1">
<thead>
<row>
  <entry align="center">Type</entry>
  <entry align="center">Type tag</entry>
  <entry align="center">Data type pointed to</entry>
</row>
</thead>
<tbody>
<row>
  <entry>Boolean</entry>
  <entry><constant>BRO_TYPE_BOOL</constant></entry>
  <entry><function>int</function></entry>
</row><row>
  <entry>Integer value</entry>
  <entry><constant>BRO_TYPE_INT</constant></entry>
  <entry><function>int</function></entry>
</row><row>
  <entry>Counter (nonnegative integers)</entry>
  <entry><constant>BRO_TYPE_COUNT</constant></entry>
  <entry><function>uint32</function></entry>
</row><row>
  <entry>Enums (enumerated values)</entry>
  <entry><constant>BRO_TYPE_ENUM</constant></entry>
  <entry><function>int</function> (see also the description of
         <link linkend="bro-event-add-val"><function>bro_event_add_val()</function></link>'s
	 <function>type_name</function> argument below)</entry>
</row><row>
  <entry>Floating-point number</entry>
  <entry><constant>BRO_TYPE_DOUBLE</constant></entry>
  <entry><function>double</function></entry>
</row><row>
  <entry>Timestamp</entry>
  <entry><constant>BRO_TYPE_TIME</constant></entry>
  <entry><function>double</function> (see also
         <link linkend="bro-util-timeval-to-double"><function>bro_util_timeval_to_double()</function></link> and
	 <link linkend="bro-util-current-time"><function>bro_util_current_time()</function></link>)</entry>
</row><row>
  <entry>Time interval</entry>
  <entry><constant>BRO_TYPE_INTERVAL</constant></entry>
  <entry><function>double</function></entry>
</row><row>
  <entry>Strings (text and binary)</entry>
  <entry><constant>BRO_TYPE_STRING</constant></entry>
  <entry><function>BroString</function> (see also the family of <function>bro_string_xxx()</function> functions)</entry>
</row><row>
  <entry>Network ports</entry>
  <entry><constant>BRO_TYPE_PORT</constant></entry>
  <entry><function>BroPort</function>, with the port number in host byte order</entry>
</row><row>
  <entry>IPv4 address</entry>
  <entry><constant>BRO_TYPE_IPADDR</constant></entry>
  <entry><function>uint32</function>, in network byte order</entry>
</row><row>
  <entry>IPv4 network</entry>
  <entry><constant>BRO_TYPE_NET</constant></entry>
  <entry><function>uint32</function>, in network byte order</entry>
</row><row>
  <entry>IPv4 subnet</entry>
  <entry><constant>BRO_TYPE_SUBNET</constant></entry>
  <entry><function>BroSubnet</function>, with the sn_net member in network byte order</entry>
</row><row>
  <entry>Record</entry>
  <entry><constant>BRO_TYPE_RECORD</constant></entry>
  <entry><function>BroRecord</function> (see also the family of
	 <function>bro_record_xxx()</function> functions and their
	  explanation below)</entry>
</row>
<row>
  <entry>Table</entry>
  <entry><constant>BRO_TYPE_TABLE</constant></entry>
  <entry><function>BroTable</function> (see also the family of
	 <function>bro_table_xxx()</function> functions and their
	  explanation below)</entry>
</row>
<row>
  <entry>Record</entry>
  <entry><constant>BRO_TYPE_SET</constant></entry>
  <entry><function>BroSet</function> (see also the family of
	 <function>bro_set_xxx()</function> functions and their
	  explanation below)</entry>
</row>
</tbody>
</tgroup>
</table>
	<para>
	    Knowing these, we can now compose a 
	   <function>request_connections</function> event:
        </para>
        <programlisting>
<![CDATA[
BroString dest_host;
BroPort dest_port;
uint32 min_size;
int req_id = 0;

bro_event_add_val(ev, BRO_TYPE_INT, NULL, &req_id);
req_id++;

bro_string_set(&dest_host, "desthost.destdomain.com");
bro_event_add_val(ev, BRO_TYPE_STRING, NULL, &dest_host);
bro_string_cleanup(&dest_host);

dest_port.dst_port = 80;
dest_port.dst_proto = IPPROTO_TCP;
bro_event_add_val(ev, BRO_TYPE_PORT, NULL, &dest_port);

min_size = 1000;
bro_event_add_val(ev, BRO_TYPE_COUNT, NULL, &min_size);
]]>
        </programlisting>
	<para>
	    The third argument to
	    <link linkend="bro-event-add-val"><function>bro_event_add_val()</function></link>
	    lets you specify a specialization of the types listed in
	    <link linkend="table-1">Table 1</link>. This is generally not necessary
	    except for one situationn: When using <constant>BRO_TYPE_ENUM</constant>. You currently
	    cannot define
	    a Bro-level enum type in Broccoli, and thus when sending an enum value, you
	    have to specify the type of the enum along with the value. For example, in order
	    to add an instance of enum <function>transport_type</function> defined in
	    Bro's <filename>bro.init</filename>, you would use
	    <programlisting>
<![CDATA[
int transport_proto = 2;
/* ... */
bro_event_add_val(ev, BRO_TYPE_ENUM, "transport_proto", &transport_proto);
]]>
	    </programlisting>
	    to get the equivalent of "udp" on the remote side. The same system is used
	    to point out type names when calling
	    <link linkend="bro-event-set-val"><function>bro_event_set_val()</function></link>,
	    <link linkend="bro-record-add-val"><function>bro_record_add_val()</function></link>,
	    <link linkend="bro-record-set-nth-val"><function>bro_record_set_nth_val()</function></link>, and
	    <link linkend="bro-record-set-named-val"><function>bro_record_set_named_val()</function></link>.
	</para>
	<para>
	    All that's left to do now is to send off the event. For this, use
	    <link linkend="bro-event-send"><function>bro_event_send()</function></link>
	    and pass it the connection handle and the event. The function returns
	    <constant>TRUE</constant> when the event could be sent right away or if
	    it was queued for later delivery. <constant>FALSE</constant> is returned
	    on error. If the event get queued, this does not indicate an error &mdash;
	    likely the connection was just not
	    ready to send the event at this point. Whenever you call
	    <link linkend="bro-event-send"><function>bro_event_send()</function></link>,
            Broccoli attempts to send as much of an existing event queue as possible.
	    Again, the event is copied internally to make it easier for you to
	    send the same event repeatedly. You clean up what you allocate.
	</para>
        <programlisting>
<![CDATA[
bro_event_send(bc, ev);
bro_event_free(ev);
]]>
        </programlisting>
        <para>
	    Two other functions may be useful to you:
	    <link linkend="bro-event-queue-length"><function>bro_event_queue_length()</function></link>
            tells you how many events are currently queued, and 
	    <link linkend="bro-event-queue-flush"><function>bro_event_queue_flush()</function></link>
	    attempts to flush the current event queue and returns the number of events that do remain
	    in the queue after the flush. <emphasis>Note:</emphasis> you do not normally need
	    to call this function, queue flushing is attempted every time you send an event.
        </para>
      </sect2>

      <sect2>
	<title id="receiving-events">Receiving events</title>
        <para>
	  Receiving events is a little more work because you need to
        </para>
        <orderedlist>	 
	  <listitem>
	    <para>tell Broccoli what to do when requested events arrive,</para>
	  </listitem>
	  <listitem>
	    <para>let the remote Bro agent know that you would like to receive those events,</para>
	  </listitem>
	  <listitem>
	    <para>find a spot in the code path suitable for extracting and processing arriving events.</para>
	  </listitem>	 
        </orderedlist>
	<para>
	  Each of these steps is explained in the following sections.
	</para>

	<sect3>
	  <title>Implementing event callbacks</title>
	  <para>
            When Broccoli receives an event, it tries to dispatch the event to callbacks
	    registered for that event type. The place where callbacks get registered is
	    called the callback registry. Any callbacks registered for the arriving
	    event's name are invoked with the parameters shipped with the event. There
	    are two styles of argument passing to the event callbacks.
	    Which one is better suited depends on your application.
	    <itemizedlist>
              <listitem>
		<para><emphasis>Expanded argument passing.</emphasis> Each event argument
		  is passed via a pointer to the callback. This makes best sense when you
		  know the type of the event and of its arguments, because it provides you
		  immediate access to arguments as when using a normal C function.
		</para>
		<para>
	    	  In order to register a callback with expanded argument passing, use
	  	  <link linkend="bro-event-registry-add"><function>bro_event_registry_add()</function></link>
		  and pass it the connection handle, the name of the event for which you
	          register the callback, the callback itself that matches the signature
	          of the <filename>BroEventFunc</filename> type, and any user data (or
	          <constant>NULL</constant>) you want to see passed to the callback on
	          each invocation. The callback's type is defined rather generically as follows:
	        </para>
                <programlisting>
<![CDATA[
typedef void (*BroEventFunc) (BroConn *bc, void *user_data, ...);
]]>
                </programlisting>
                <para>
                  It requires a connection handle as its first argument
	          and a pointer to user-provided callback data as the second argument.
                  Broccoli will pass the connection handle of the connection on which the event
                  arrived through to the callback. <function>BroEventFunc</function>s
	          are variadic, because each callback you provide is directly invoked with
	          pointers to the parameters of the event, in a format directly usable in C.
	          All you need to know is what type to point to in order to receive the
	          parameters in the right layout. Refer to <link linkend="table-1">Table 1</link>
	          again for a summary of those types. Record types are more involved and are
	          addressed in more detail <link linkend="records">below</link>.
                </para>
	        <note>
	          <para>Note that <emphasis>all</emphasis> parameters are passed to the
	            callback as pointers, even elementary types such as <constant>int</constant>s
	            that would normally be passed directly.
		    Also note that Broccoli manages the lifecycle of event parameters
	            and therefore you do <emphasis>not</emphasis> have to clean them up inside
	            the event handler. 
                  </para>
                </note>
                <para>
	          Continuing our example, we will want to process the connection reports
	          that contain the responses to our <function>report_conns</function>
	          event. Let's assume those look as follows:
	        </para>
                <programlisting>
<![CDATA[
event remote_conn(req_id: int, conn: connection);
]]>
                </programlisting>
	        <para>
                  The reply events contain the request ID so we can associate requests
	          with replies, and a connection record (defined in <filename>bro.init</filename>
	          in Bro. (It'd be nicer to report all replies in a single event but we'll
	          ignore that for now.) For this event, our callback would look like this:
	        </para>
                <programlisting>
<![CDATA[
void remote_conn_cb(BroConn *bc, void *user_data, int *req_id, BroRecord *conn);
]]>
                </programlisting>
	        <para>
	          Once more, you clean up what you allocate, and since you never allocated the
	      	  space these arguments point to, you also don't clean them up. Finally, we register
	      	  the callback using
	      	  <link linkend="bro-event-registry-add"><function>bro_event_registry_add()</function></link>:	    
		</para>
	        <programlisting>
<![CDATA[
bro_event_registry_add(bc, "remote_conn", remote_conn_cb, NULL);
]]>
	        </programlisting>
		<para>
		  In this case we have no additional data to be passed into the
		  callback, so we use <constant>NULL</constant> for the last argument.
		  If you have multiple events you are interested in, register
		  each one in this fashion.
		</para>
	      </listitem>
	      <listitem>
		<para><emphasis>Compact argument passing.</emphasis> This is designed for
		  situations when you have to determine how to handle different types of
		  events at runtime, for example when writing language bindings or when
		  implementing generic event handlers for multiple event types.
		  The callback is passed a connection handle and the
		  user data as above but is only passed one additional pointer, to a
		  <type>BroEvMeta</type> structure. This structure contains all metadata
		  about the event, including its name, timestamp (in UTC) of creation,
		  number of arguments, the arguments'
		  types (via type tags as listed in <link linkend="table-1">Table 1</link>),
		  and the arguments themselves.
		</para>
		<para>
	    	  In order to register a callback with compact argument passing, use
	  	  <link linkend="bro-event-registry-add-compact"><function>bro_event_registry_add_compact()</function></link>
		  and pass it similar arguments as you'd use with
	  	  <link linkend="bro-event-registry-add"><function>bro_event_registry_add()</function></link>.
		  The callback's type is defined as follows:
	        </para>
                <programlisting>
<![CDATA[
typedef void (*BroCompactEventFunc) (BroConn *bc, void *user_data, BroEvMeta *meta);
]]>
                </programlisting>
	        <note>
	          <para>As before, Broccoli manages the lifecycle of event parameters.
	            You do not  have to clean up the <type>BroEvMeta</type>
		    structure or any of its contents.
                  </para>
                </note>
                <para>
		  Below is sample code for extracting the arguments form the <type>BroEvMeta</type>
		  structure, using our running example. This is still written with the assumption
		  that we know the types of the arguments, but note that this is not a requirement
		  for this style of callback.
	        </para>
                <programlisting>
<![CDATA[
void remote_conn_cb(BroConn *bc, void *user_data, BroEvMeta *meta)
{
	int *req_id;
	BroRecord *rec;

	/* For demonstration, print out the event's name: */

	printf("Handling a %s event.\n", meta->ev_name);

	/* Sanity-check the number of arguments: */

	if (meta->ev_numargs != 2)
		{ /* error */ }

	/* Sanity-check the argument types: */

	if (meta->ev_args[0].arg_type != BRO_TYPE_INT)
		{ /* error */ }

	if (meta->ev_args[1].arg_type != BRO_TYPE_RECORD)
		{ /* error */ }

	req_id = (int *) meta->ev_args[0].arg_data;
	rec = (BroRecord *) meta->ev_args[1].arg_data;

	/* ... */
}
]]>
                </programlisting>
	        <para>
		  Finally, register the callback using
	      	  <link linkend="bro-event-registry-add-compact"><function>bro_event_registry_add_compact()</function></link>:	    
		</para>
	        <programlisting>
<![CDATA[
bro_event_registry_add_compact(bc, "remote_conn", remote_conn_cb, NULL);
]]>
	        </programlisting>
	      </listitem>
	    </itemizedlist>
	  </para>
	</sect3>

	<sect3>
	  <title id="event-request">Requesting event delivery</title>
          <para>
	    At this point, Broccoli knows what to do with the requested events upon
	    arrival.  What's left to do is to let the remote Bro know that you
	    would like to receive the events for which you registered. If you haven't
	    yet called <link linkend="bro-conn-connect"><function>bro_conn_connect()</function></link>,
	    then there is nothing to do, since that function will request the registered
	    events anyway. Once connected, you can still request events. To do so, call
	    <link linkend="bro-event-registry-request"><function>bro_event_registry_request()</function></link>:
	  </para>
          <programlisting>
<![CDATA[
bro_event_registry_request(bc);
]]>
          </programlisting>
          <para>
	    This mechanism also implies that no unrequested events will be delivered
	    to us (and if that happened for whatever reason, the event would simply
	    be dropped on the floor).
	  </para>
	  <note>
	    <para><emphasis>Note that at the moment you cannot unrequest events, nor
		can you request events based on predicates on the values of the
		events' arguments.</emphasis></para>
          </note>
	</sect3>

	<sect3>
	  <title>Reading events from the connection handle</title>
	  <para>
	    At this point the remote Bro will start sending you the requested events
	    once they are triggered. What is left to do is to read the arriving events
	    from the connection and trigger dispatching them to the registered callbacks.
	  </para>
	  <para>
	    If you are writing a new Bro-enabled application, this is easy, and you can
	    choose among two approaches: polling explicitly via Broccoli's API, or using
	    <function>select()</function> on the file handle associated with a <type>BroConn</type>.
	    The former case is particularly straightforward; all you need to do is
	    call 
	    <link linkend="bro-conn-process-input"><function>bro_conn_process_input()</function></link>,
	    which will go off and check if any events have arrived and if so, dispatch
	    them accordingly. This function does not block &mdash; if no events have
	    arrived, then the call will return immediately. For more fine-grained control
	    over your I/O handling, you will probably want to use
	    <link linkend="bro-conn-get-fd"><function>bro_conn_get_fd()</function></link>
	    to obtain the file descriptor of your connection and then incorporate that
	    in your standard <function>FD_SET</function>/<function>select()</function>
	    code. Once you have determined that data in fact are ready to be read from
	    the obtained file descriptor, you can then try another
	    <link linkend="bro-conn-process-input"><function>bro_conn_process_input()</function></link>,
	    this time knowing that it'll find something to dispatch.
	  </para>
	  <para>
	    As a side note, if you don't process arriving events frequently enough,
	    then TCP's flow control will start to slow down the sender until eventually
	    events will queue up and be dropped at the sending end.
	  </para>
	</sect3>
      </sect2>

      <sect2>
	<title id="records">Handling records</title>
        <para>
	  Broccoli supports record structures, i.e., types that pack a set of values
	  together, placing each value into its own field. In Broccoli, the way you handle
	  records is somewhat similar to events:
	  after creating an empty record (of opaque type <type>BroRecord</type>, you can
	  iteratively add fields and values to it. The main difference is that you must specify a
	  field name with the value; each value in a record can be identified both by position
	  (a numerical index starting from zero), and by field name. You can retrieve vals
	  in a record by field index or field name. You can also reassign values.
	  There is no explicit, IDL-style definition of record types. You define the type of
	  a record implicitly by the sequence of field names and the sequence of the types
	  of the values you put into the record.
	</para>
	<para>
	  Note that all fields in a record must be assigned before it can be shipped.
	</para>
	<para>
	  The API for record composition consists of
	  <link linkend="bro-record-new"><function>bro_record_new()</function></link>,
	  <link linkend="bro-record-free"><function>bro_record_free()</function></link>,
	  <link linkend="bro-record-add-val"><function>bro_record_add_val()</function></link>,
	  <link linkend="bro-record-set-nth-val"><function>bro_record_set_nth_val()</function></link>, and
	  <link linkend="bro-record-set-named-val"><function>bro_record_set_named_val()</function></link>.
	</para>
	<para>
	  On records that use field names, the names of individual fields can be extracted using
	  <link linkend="bro-record-get-nth-name"><function>bro_record_get_nth_name()</function></link>.
	  Extracting values from a record is done using
	  <link linkend="bro-record-get-nth-val"><function>bro_record_get_nth_val()</function></link> and
	  <link linkend="bro-record-get-named-val"><function>bro_record_get_named_val()</function></link>.
	  The former allows numerical indexing of the fields in the record, the latter provides
	  name-based lookups. Both need to be passed the record you want to extract a value from,
	  the index or name of the field, and either a pointer to an <type>int</type> holding a
	  <type>BRO_TYPE_xxx</type> value (see again <link linkend="table-1">Table 1</link> for a
	  summary of those types) or <constant>NULL</constant>. The pointer, if not
	  <constant>NULL</constant>, serves two purposes: type checking and type retrieval.
	  Type checking is performed if the value of the <type>int</type> upon calling the
	  functions is not <type>BRO_TYPE_UNKNOWN</type>. The type tag of the requested record
	  field then has to match the type tag stored in the <type>int</type>, otherwise
          <constant>NULL</constant> is returned. If the <type>int</type> stores <type>BRO_TYPE_UNKNOWN</type>
          upon calling, no type-checking is performed. In <emphasis>both</emphasis> cases,
	  the <emphasis>actual</emphasis> type of the
	  requested record field is returned in the <type>int</type> pointed to upon
	  return from the function. Since you have no guarantees of the type of the value
	  upon return if you pass <constant>NULL</constant> as the <type>int</type> pointer,
	  this is a bad idea and either <type>BRO_TYPE_UNKNOWN</type> or another type value
	  should always be used.
        </para>
        <para>
	  For example, you could extract the value of the record field "label", which
	  we assume should be a string, in the following ways:
	</para>
        <programlisting>
<![CDATA[
BroRecord *rec = /* obtained somehow */
BroString *string;
int type;

/* --- Example 1 --- */

type = BRO_TYPE_STRING; /* Use type-checking, will not accept other type */

if (! (string = bro_record_get_named_val(rec, "label", &type))) {
	/* Error handling, either there's no field of that value,
	 * or the value is not of BRO_TYPE_STRING. The actual
	 * type is now stored in "type".
	 */
}

/* --- Example 2 --- */

type = BRO_TYPE_UNKNOWN; /* No type checking, just report the existant type */

if (! (string = bro_record_get_named_val(rec, "label", &type))) {
	/* Error handling, no field of that name exists. */
}

printf("The type of the value in field 'label' is %i\n", type);

/* --- Example 3 --- */

if (! (string = bro_record_get_named_val(rec, "label", NULL))) {
	/* Error handling, no field of that name exists. */
}

/* We now have a value, but we can't really be sure of its type */

]]>
        </programlisting>	
	<para>
	  Record fields can be records, for example in the case of Bro's standard
	  connection record type. In this case, in order to get to a nested record, you
	  use <constant>BRO_TYPE_RECORD</constant>:
	</para>
        <programlisting>
<![CDATA[
void remote_conn_cb(BroConn *bc, int *req_id, BroRecord *conn) {
	BroRecord *conn_id;
	int type = BRO_TYPE_RECORD;
	if (! (conn_id = bro_record_get_named_val(conn, "id", &type))) {
		/* Error handling */
	}
}
]]>
        </programlisting>	
      </sect2>

      <sect2>
	<title id="tables">Handling tables</title>
        <para>
	  Broccoli supports Bro-style tables, i.e., associative containers that map
	  instances of a key type to an instance of a value type. A given key
	  can only ever point to a single value. The key type can be
	  <emphasis>composite</emphasis>, i.e., it may consist of an ordered
	  sequence ofdifferent types, or it can be <emphasis>direct</emphasis>,
	  i.e., consisting of a single type (such as an integer, a string, or
	  a record).
        </para>
	<para>
	  The API for table manipulation consists of
	  <link linkend="bro-table-new"><function>bro_table_new()</function></link>,
	  <link linkend="bro-table-free"><function>bro_table_free()</function></link>,
	  <link linkend="bro-table-insert"><function>bro_table_insert()</function></link>,
	  <link linkend="bro-table-find"><function>bro_table_find()</function></link>,
	  <link linkend="bro-table-get-size"><function>bro_table_get_size()</function></link>,
	  <link linkend="bro-table-get-types"><function>bro_table_get_types()</function></link>,
	  and
	  <link linkend="bro-table-foreach"><function>bro_table_foreach()</function></link>.
        </para>
	<para>
	  Tables are handled similarly to records in that typing is determined
	  dynamically by the initial key/value pair inserted. The resulting types
	  can be obtained via 	
	  <link linkend="bro-table-get-types"><function>bro_table_get_types()</function></link>.
	  Should the types not have been determined yet, <constant>BRO_TYPE_UNKNOWN</constant>
	  will result. Also, as with records,
	  values inserted into the table are copied internally, and the ones passed
	  to the insertion functions remain unaffected.
        </para>
	<para>
	  In contrast to records, table entries can be iterated. By passing a function
	  of signature 
	  <link linkend="brotablecallback"><function>BroTableCallback()</function></link>
	  and a pointer to data of your choosing,
	  <link linkend="bro-table-foreach"><function>bro_table_foreach()</function></link>
	  will invoke the given function for each key/value pair stored in the table.
	  Return <constant>TRUE</constant> to keep the iteration going, or <constant>FALSE</constant>
	  to stop it.
        </para>
	<caution><para>
	  The main thing to know about Broccoli's tables is how to use composite key
	  types. To avoid additional API calls, you may treat composite key types
	  exactly as records, though you do not need to use field names when assigning
	  elements to individual fields. So in order to insert a key/value pair, you
	  create a record with the needed items assigned to its slots, and use this
	  record as the key object. In order to differentiate composite index types
	  from direct ones consisting of a single record, use <constant>BRO_TYPE_LIST</constant>
	  as the type of the record, as opposed to <constant>BRO_TYPE_RECORD</constant>.
	  Broccoli will then know to interpret the record
	  as an ordered sequence of items making up a composite element, not a regular
	  record.
        </para></caution>
	<para>
	  <filename>brotable.c</filename> in the test subdirectory of the Broccoli tree
	  contains an extensive example of using tables with composite as well as direct
	  indexing types.
        </para>
      </sect2>

      <sect2>
	<title id="sets">Handling sets</title>
        <para>
	  Sets are essentially tables with void value types.
	  The API for set manipulation consists of
	  <link linkend="bro-set-new"><function>bro_set_new()</function></link>,
	  <link linkend="bro-set-free"><function>bro_set_free()</function></link>,
	  <link linkend="bro-set-insert"><function>bro_set_insert()</function></link>,
	  <link linkend="bro-set-find"><function>bro_set_find()</function></link>,
	  <link linkend="bro-set-get-size"><function>bro_set_get_size()</function></link>,
	  <link linkend="bro-set-get-type"><function>bro_set_get_type()</function></link>,
	  and
	  <link linkend="bro-set-foreach"><function>bro_set_foreach()</function></link>.
        </para>
      </sect2>

      <sect2>
	<title>Associating data with connections</title>
        <para>
	    You will often find that you would like to connect data with
	    a <filename>BroConn</filename>. Broccoli provides an API that
	    lets you associate data items with a connection handle through
	    a string-based key&ndash;value registry. The functions of interest
	    are
	    <link linkend="bro-conn-data-set"><function>bro_conn_data_set()</function></link>,
	    <link linkend="bro-conn-data-get"><function>bro_conn_data_get()</function></link>, and
	    <link linkend="bro-conn-data-del"><function>bro_conn_data_del()</function></link>.
	    You need to provide a string identifier for a data item and can then use
	    that string to register, look up, and remove the associated data item.
	    Note that there is currently no mechanism to trigger a destructor
	    function for registered data items when the Bro connection is terminated.
	    You therefore need to make sure that all data items that you do
	    not have pointers to via some other means are properly released before
	    calling 
	    <link linkend="bro-disconnect"><function>bro_disconnect()</function></link>.
        </para>
      </sect2>

      <sect2>
	<title id="config-files">Configuration files</title>
        <para>	  
	    Imagine you have instrumented the mother of all server applications.
	    Building it takes forever, and every now and then you need to change
	    some of the parameters that your Broccoli code uses, such as the host names
	    of the Bro agents to talk to.
	    To allow you to do this quickly, Broccoli comes with support for
	    configuration files. All you need to do is change the settings in the
	    file and restart the application (we're considering adding support
	    for volatile configuration items that are read from the file every
	    time they are requested).	  
        </para>
        <para>
	    A configuration is read from a single configuration file.
	    This file can be read from two different locations:
	    <itemizedlist>
              <listitem>
                <para>The system-wide configuration file. You can obtain the location
	          of this config file by running <filename>broccoli-config --config</filename>.
		</para>
              </listitem>
              <listitem>
                <para>Alternatively, a per-user configuration file stored in <filename>~/.broccoli.conf</filename>
		  can be used.
		</para>
              </listitem>
            </itemizedlist>
            If a user has a configuration file in <filename>~/.broccoli.conf</filename>,
	    it is used exclusively, otherwise the global one is used.
         </para>
         <caution>
	  <para><emphasis><filename>~/.broccoli.conf</filename> will only be used if
	    it is a regular file, not executable, and neither group nor others have
	    any permissions on the file. That is, the file's permissions must look
	    like <function>-rw-------</function> or <function>-r--------</function>.
	    </emphasis></para>
         </caution>
         <para>
	    In the configuration file, a "#" anywhere starts a comment that runs
	    to the end of the line. Configuration items are specified as key-value
	    pairs:
        </para>
        <programlisting>
<![CDATA[
# This is the Broccoli system-wide configuration file.
#
# Entries are of the form <identifier> <value>, where the identifier
# is a sequence of letters, and value can be a string (including
# whitespace), and floating point or integer numbers. Comments start
# with a "#" and go to the end of the line. For boolean values, you
# may also use "yes", "on", "true", "no", "off", or "false".
# Strings may contain whitespace, but need to be surrounded by
# double quotes '"'.
#
# Examples:
#
Foo/PeerName          mybro.securesite.com
Foo/PortNum           123
Bar/SomeFloat         1.23443543
Bar/SomeLongStr       "Hello World"
]]>
        </programlisting>
        <para>
            You can also have multiple sections in your configuration. Your application can
	    select a section as the current one, and queries for configuration settings will
	    then only be answered with values specified in that section. A section is started
	    by putting its name (no whitespace please) between square brackets. Configuration
	    items positioned before the first section title are in the default domain and
	    will be used by default.
        </para>
        <programlisting>
<![CDATA[
# This section contains all settings for myapp.
[ myapp ]
]]>
        </programlisting>
        <para>
	    You can name identifiers any way you like, but to keep things
	    organized it is recommended to keep a namespace hierarchy similar
	    to the file system. In the code, you can query configuration
	    items using
	    <link linkend="bro-conf-get-str"><function>bro_conf_get_str()</function></link>,
            <link linkend="bro-conf-get-int"><function>bro_conf_get_int()</function></link>, and
            <link linkend="bro-conf-get-dbl"><function>bro_conf_get_dbl()</function></link>.
	    You can switch between sections using 
            <link linkend="bro-conf-set-domain"><function>bro_conf_set_domain()</function></link>.
        </para>
      </sect2>      

      <sect2>
	<title id="buffers">Using dynamic buffers</title>
        <para>
	    Broccoli provides an API for dynamically allocatable, growable, shrinkable,
	    and consumable buffers with <function>BroBuf</function>s. You may or may
	    not find this useful &mdash; Broccoli mainly provides this feature in
	    <filename>broccoli.h</filename> because these buffers are used internally
	    anyway and because they are typical case of something that people implement
	    themselves over and over again, for example to collect a set of data before
	    sending it through a file descriptor, etc.
        </para>
        <para>
	    The buffers work as follows. The structure implementing a buffer is
	    called BroBuf. BroBufs are initialized to a default size when created via
	    <link linkend="bro-buf-new"><function>bro_buf_new()</function></link>,
	    and released using 
	    <link linkend="bro-buf-free"><function>bro_buf_free()</function></link>.
            Each BroBuf has a content
	    pointer that points to an arbitrary location between the start of the
            buffer and the first byte after the last byte currently
            used in the buffer (see buf_off in the illustration below). The content
	    pointer can seek to arbitrary locations, and data can be copied from and
	    into the buffer, adjusting the content pointer accordingly.
	    You can repeatedly append data to end of the buffer's used contents using
	    <link linkend="bro-buf-append"><function>bro_buf_append()</function></link>.	    
        </para>
        <programlisting>
<![CDATA[

   <---------------- allocated buffer space ------------>
   <======== used buffer space ========>
   ^              ^                    ^               ^                 
   |              |                    |               |
   `buf           `buf_ptr             `buf_off        `buf_len
]]>
        </programlisting>
        <para>
	    Have a look at the following functions for the details:
	    <link linkend="bro-buf-new"><function>bro_buf_new()</function></link>,
	    <link linkend="bro-buf-free"><function>bro_buf_free()</function></link>,
	    <link linkend="bro-buf-append"><function>bro_buf_append()</function></link>,
	    <link linkend="bro-buf-consume"><function>bro_buf_consume()</function></link>,
	    <link linkend="bro-buf-reset"><function>bro_buf_reset()</function></link>,
	    <link linkend="bro-buf-get"><function>bro_buf_get()</function></link>,
	    <link linkend="bro-buf-get-end"><function>bro_buf_get_end()</function></link>,
	    <link linkend="bro-buf-get-size"><function>bro_buf_get_size()</function></link>,
	    <link linkend="bro-buf-get-used-size"><function>bro_buf_get_used_size()</function></link>,
	    <link linkend="bro-buf-ptr-get"><function>bro_buf_ptr_get()</function></link>,
	    <link linkend="bro-buf-ptr-tell"><function>bro_buf_ptr_tell()</function></link>,
	    <link linkend="bro-buf-ptr-seek"><function>bro_buf_ptr_seek()</function></link>,
	    <link linkend="bro-buf-ptr-check"><function>bro_buf_ptr_check()</function></link>, and
	    <link linkend="bro-buf-ptr-read"><function>bro_buf_ptr_read()</function></link>.
        </para>
      </sect2>
    </sect1>

    <sect1>
      <title id="encryption">Configuring encrypted communication</title>
      <para>
	Encrypted communication between Bro peers takes place over an SSL connection in
	which both endpoints of the connection are authenticated. This requires at least
	some PKI in the form of a certificate authority (CA) which you use to issue and sign
	certificates for your Bro peers. To facilitate the SSL setup, each peer requires
	three documents: a certificate signed by the CA and containing the public key, the
	corresponding private key, and a copy of the CA's certificate.
      </para>
      <para>
        The OpenSSL command line tool <command>openssl</command> can be used to create all
	files neccessary, but its unstructured arguments and poor documentation make it
	a pain to use and waste lots of people a lot of time<footnote><para>In other
	documents and books on OpenSSL you will find this expressed more politely, using
	terms such as "daunting to the uninitiated", "challenging", "complex", "intimidating".
	</para></footnote>. Therefore, the Bro distribution comes with two scripts,
	<command>ca-create</command> and <command>ca-issue</command>. You use the former
	once to set up your CA, and the latter to create a certificate for each of the Bro
	peers in your infrastructure.
	<itemizedlist>	 
	  <listitem>
	    <para><command>ca-create</command> lets you choose a directory in which the
	      CA maintains its files. If you set <varname>BRO_CA_DIR</varname> in your
	      environment, it will be used for this purpose. After entering a passphrase
	      for the private key of your CA, you can find the self-signed certificate
	      of your CA in <filename>$BRO_CA_DIR/ca_cert.pem</filename>.
	    </para>
	  </listitem>
	  <listitem>
	    <para><command>ca-issue</command> first requires the directory of the CA,
	      offering <filename>$BRO_CA_DIR</filename> if that is found. It asks you for
	      a prefix for the certificate to be generated, for the passphrase of the
	      private key of the CA so the new certificate can be signed, for the
	      passphrase for the new private key, and for a few parameters that make up
	      the "distinguished name" of the certificate. This name (i.e., the combination
	      of all the fields you enter a value for) must be unique among all your Bro
	      peers. Once that is done, you find a new certificate named
	      <filename>&lt;prefix&gt;.pem</filename> in your current
	      directory. This file actually consists of two of the three cryptographic
	      documents mentioned above, namely the new certificate and the private key.
              We refer to it as "certificate" for simplicity.
	    </para>
	  </listitem>
	</itemizedlist>
	In order to enable encrypted communication for your Broccoli application, you
	need to put the CA certificate and the peer certificate in the
	<varname>/broccoli/ca_cert</varname> and 
	<varname>/broccoli/host_cert</varname> keys, respectively, in the configuration file.
	To quickly enable/disable a certificate configuration, the
	<varname>/broccoli/use_ssl</varname> key can be used.
	<caution>
          <para><emphasis>This is where you configure whether to use encrypted or unencrypted
	    connections.</emphasis></para>
          <para>If the <varname>/broccoli/use_ssl</varname> key is present and set to one of
		"yes", "true", "on", or 1, then SSL will be used and an incorrect or
		missing certificate configuration will cause connection attempts to fail.
		If the key's value is one of "no", "false", "off", or 0, then in no case
		will SSL be used and connections will always be cleartext.
	  </para>
          <para>If the <varname>/broccoli/use_ssl</varname> key is <emphasis>not</emphasis>
		present, then SSL will be used if a certificate configuration is
		found, and invalid certificates will cause the connection to fail.
		If no certificates are configured, cleartext connections will be used.
	  </para>
	  <para>In no case does an SSL-enabled setup ever fall back to a cleartext one.</para>
        </caution>
      </para>
      <programlisting>
<![CDATA[
/broccoli/use_ssl	   yes
/broccoli/ca_cert          <path>/ca_cert.pem
/broccoli/host_cert        <path>/bro_cert.pem
]]>
      </programlisting>
      <para>
        In a Bro policy, you need to load the <filename>listen-ssl.bro</filename> policy and
	redef <varname>ssl_ca_certificate</varname> and <varname>ssl_private_key</varname>,
	defined in <filename>bro.init</filename>:
      </para>
      <programlisting>
<![CDATA[
@load listen-ssl

redef ssl_ca_certificate   = "<path>/ca_cert.pem";
redef ssl_private_key      = "<path>/bro.pem";
]]>
      </programlisting>
      <para>
	By default, you will be prompted for the passphrase for the private key matching
	the public key in your agent's certificate. Depending on your application's user
	interface and deployment, this may be inappropriate. You can store the passphrase
	in the config file as well, using the following identifier:
      </para>
      <programlisting>
<![CDATA[
/broccoli/host_pass        foobar
]]>
      </programlisting>
      <caution>
        <para><emphasis>Make sure that access to your configuration is restricted.</emphasis></para>
        <para>
	  If you provide the passphrase this way, it is obviously essential to have
	  restrictive permissions on the configuration file. Broccoli partially enforces
	  this. Please refer to the section on
	  <link linkend="config-files">configuration files</link> for details.
        </para>
      </caution>
    </sect1>

    <sect1>
      <title id="bro-event-config">Configuring event reception in Bro policies</title>
      <para>
	Before a remote Bro will accept your connection and your events, it needs to have its
	policy configured accordingly:	  
	<orderedlist>	 
	  <listitem>
	    <para>Load either <filename>listen-ssl</filename> or <filename>listen-clear</filename>,
	      depending on whether you want to have encrypted or cleartext communication. Obviously,
	      encrypting the event exchange is recommended and cleartext should only be used for
	      early experimental setups. See below for details on how to set up encrypted
	      communication via SSL.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      You need to find a port to use for the Bros and Broccoli applications that will
	      listen for connections. Every such agent can use a different port, though default
	      ports are provided in the Bro policies.
	      To change the port the Bro agent will be listening on from its default
	      redefine the <varname>listen_port_ssl</varname> or
	      <varname>listen_port_clear</varname> variables from <filename>listen-clear.bro</filename>
	      or <filename>listen-ssl.bro</filename>, respectively. Have a look at these policies as well
	      as <filename>remote.bro</filename> for the default values. Here is the policy
	      for the unencrypted case:
	    </para>
	    <programlisting>
<![CDATA[
@load listen-clear

redef listen_port_clear = 12345/tcp;
]]>
            </programlisting>
	    <para>
	      Including the settings for the cryptographic files introduced in the previous section, 
	      here is the encrypted one:
	    </para>
	    <programlisting>
<![CDATA[
@load listen-ssl

redef listen_port_ssl = 12345/tcp;
redef ssl_ca_certificate   = "<path>/ca_cert.pem";
redef ssl_private_key      = "<path>/bro.pem";
]]>
            </programlisting>
	  </listitem>
	  <listitem>
	    <para>
	      The policy controlling which peers a Bro agent will communicate with and how this
	      communication will happen are defined in the <varname>destinations</varname> table
	      defined in <filename>remote.bro</filename>. This table contains entries of type
	      <type>Destination</type>, whose members mostly provide default values so you do not
	      need to define everything. You need to come up with a tag for the connection
	      under which it can be found in the table (a creative one would be "broccoli"),
	      the IP address of the peer, the pattern of names of the events the Bro will accept
	      from you, whether you want Bro to connect to your
	      machine on startup or not, if so, a port to connect to (defaults are
	      <varname>default_port_ssl</varname> and <varname>default_port_clear</varname>, also
	      defined in <filename>remote.bro</filename>), a retry timeout, whether to use SSL,
	      and the class of a connection as set on the Broccoli side via
	    <link linkend="bro-conn-set-class"><function>bro_conn_set_class()</function></link>.
	    </para>
	    <para>
	      An example could look as follows:
	    </para>
	    <programlisting>
<![CDATA[

redef Remote::destinations += {
	["broping"] = [$host = 127.0.0.1, $class="broping", $events = /ping/, $connect=F, $ssl=F]
};
]]>
            </programlisting>
	    <para>
	      This example is taken from <filename>broping.bro</filename>, the policy the
	      remote Bro must run when you want to use the <command>broping</command> tool
	      explained in the <link linkend="testing">section on testing</link> below.
	      It will allow an agent on the local host to connect and send "ping" events.
	      Our Bro will not attempt to connect, and incoming connections will be expected
	      in cleartext.
	    </para>
	  </listitem>
	</orderedlist>
      </para>
    </sect1>

    <sect1>
      <title id="broccoli-debugging">Configuring debugging output</title>
      <para>
	  If your Broccoli installation was configured with <command>--enable-debug</command>,
	  Broccoli will report two kinds of debugging information: (<emphasis>i</emphasis>)
	  function call traces and
	  (<emphasis>ii</emphasis>) individual debugging messages. Both are enabled by default, but can be adjusted
	  in two ways.
	  <itemizedlist>	 
	    <listitem>
	      <para>In the configuration file: in the appropriate section of the configuration
	        file, you can set the keys <function>/broccoli/debug_messages</function> and
		<function>/broccoli/debug_calltrace</function> to <function>on</function>/<function>off</function>
		to enable/disable the corresponding output.
	      </para>
            </listitem>
	    <listitem>
	      <para>In code: you can set the variables 
	      	<link linkend="bro-debug-calltrace"><function>bro_debug_calltrace</function></link> and
	        <link linkend="bro-debug-messages"><function>bro_debug_messages</function></link>
	        to 1/0 at any time to enable/disable the corresponding output.
	      </para>
            </listitem>
	  </itemizedlist>	 
      </para>
      <para>
	  By default, debugging output is inactive (even with debuggin support compiled in).
	  You need to enable it explicitly either in your code by assigning 1 to 
	  <link linkend="bro-debug-calltrace"><function>bro_debug_calltrace</function></link> and
	  <link linkend="bro-debug-messages"><function>bro_debug_messages</function></link>,
	  or by enabling it in the configuration file.
      </para>
    </sect1>

    <sect1>
      <title id="testing">Test programs</title>
      <para>
	  The Broccoli distribution comes with a few small test programs,
	  located in the <filename>test/</filename> directory of the tree.
	  The most notable one is &bp;
	  <footnote><para>Pronunciation is said to be somewhere on the continuum between
	  "brooping" and "burping".</para></footnote>, a mini-version of ping.
	  It sends "ping" events to a remote Bro agent, expecting "pong" events
	  in return. It operates in two flavours: one uses atomic types for sending
	  information across, and the other one uses records. The Bro agent you want
	  to ping needs to run either the <filename>broping.bro</filename> or
	  <filename>broping-record.bro</filename> policies. You can find these
	  in the <filename>test/</filename> directory of the source tree, and
	  in <filename>&lt;prefix&gt/share/broccoli</filename> in the installed
	  version. <filename>broping.bro</filename> is shown below. By default,
	  pinging a Bro on the same machine is configured. If you want your Bro
	  to be pinged from another machine, you need to update the
	  <varname>destinations</varname> variable accordingly.
      </para>
      <programlisting>
<![CDATA[
@load listen-clear;

global ping_log = open_log_file("ping");

redef Remote::destinations += {
	["broping"] = [$host = 127.0.0.1, $events = /ping/, $connect=F, $retry = 60 secs, $ssl=F]
};

event ping(src_time: time, seq: count)
{
        event pong(src_time, current_time(), seq);
}

event pong(src_time: time, dst_time: time, seq: count)
{
        print ping_log, fmt("ping received, seq %d, %f at src, %f at dest, one-way: %f",
                            seq, src_time, dst_time, dst_time-src_time);
}
]]>
      </programlisting>
      <para>
        &bp; sends ping events to Bro. Bro accepts those because they are configured
	accordingly in the destinations table. As shown in the policy, ping events
	trigger pong events, and &bc; requests delivery of all pong events back to it.
	When running &bp;, you'll see something like this:
      </para>
      <programlisting>
<![CDATA[
cpk25@localhost:/home/cpk25/devel/broccoli > ./test/broping
pong event from 127.0.0.1: seq=1, time=0.004700/1.010303 s
pong event from 127.0.0.1: seq=2, time=0.053777/1.010266 s
pong event from 127.0.0.1: seq=3, time=0.006435/1.010284 s
pong event from 127.0.0.1: seq=4, time=0.020278/1.010319 s
pong event from 127.0.0.1: seq=5, time=0.004563/1.010187 s
pong event from 127.0.0.1: seq=6, time=0.005685/1.010393 s
]]>
      </programlisting>
    </sect1>      
  </chapter>
  
  <chapter id="api">
    <title id="api.title">Broccoli API Reference</title>
    &bc-header;
  </chapter>

  <appendix>
    <title>Appendix</title>
    <sect1 id="license">
      <title id="license.title">License</title>
      <para>
	Copyright (C) 2004-2008 Christian Kreibich and various contributors.
      </para>
      <para>	
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to
	deal in the Software without restriction, including without limitation the
	rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	sell copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
      </para>
      <para>
	The above copyright notice and this permission notice shall be included in
	all copies of the Software and its documentation and acknowledgment shall be
	given in the documentation and software packages that this Software was
	used.
      </para>
      <para>	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
	THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
	IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.	
      </para>
    </sect1>
    <sect1 id="about">
      <title>About this document</title>
      <para>
	This documentation is maintained in SGML <ulink url="http://www.docbook.org">DocBook</ulink>,
	API documentation is extracted from the code using the
	<ulink url="http://www.gtk.org/gtk-doc/"><command>gtk-doc</command></ulink> tools.
      </para>
    </sect1>
  </appendix>
</book>
